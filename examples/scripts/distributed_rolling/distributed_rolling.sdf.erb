<?xml version="1.0" ?>
<%
  # World generator
  #
  # Command line options (usage erb [opt]=[arg]):
  # type: primary / secondary / standalone (not distributed)
  # p: number of performer spheres
  # s: seed for random number generator
  # lv: 1 to generate level visuals
  # f: Fun! Random shapes!

  ###############################################
  #                                             #
  #           COMMAND LINE ARGUMENTS            #
  #                                             #
  ###############################################

  vars = ARGV.take_while {|arg| arg[/^\w+=/]}
  ARGV.slice!(0, vars.size)
  vars.each do |var|
    k, v = var.split('=', 2)
    TOPLEVEL_BINDING.eval %Q(#{k} = "#{v}")
  end

  primary = false;
  secondary = false;
  if (defined? type)
    if (type.to_s == 'primary')
      primary = true
    elsif (type.to_s == 'secondary')
      secondary = true
    elsif (type.to_s == 'standalone')
      primary = true
      secondary = true
    end
  end

  performers = 0
  if (defined? p)
    performers = p.to_i
  end

  level_visuals = false
  if (defined? lv and lv == '1')
    level_visuals = true
  end

  $fun = false
  if (defined? f and f == '1')
    $fun = true
  end

  seed = rand(0..10000000)
  if (defined? s)
    seed = s.to_i
  end
  srand(seed)

  ###############################################
  #                                             #
  #                  BLOCKS                     #
  #                                             #
  ###############################################

  total_steps = $fun ? 6 : 1
  total_columns = $fun ? 20 : performers
  block_width = 2.0
  block_length = $fun ? 3.0 : total_columns * 2
  block_thickness = 0.1
  slope = Math::PI / 6
  level_height = block_length * Math::sin(slope)
  level_buffer = 0.5

  blocks = []
  (0..total_steps-1).each do |step|
    (0..total_columns-1).each do |column|
      blocks.push(
      {
        :name => 'block_' + step.to_s + '_' + column.to_s,
        :x_pos => block_length * step * Math::cos(slope),
        :y_pos => block_width * column,
        :z_pos => -block_length * step * Math::sin(slope)
      })
    end
  end

  ###############################################
  #                                             #
  #                PERFORMERS                   #
  #                                             #
  ###############################################

  # Limit shape sizes
  size_min = 0.1
  size_max = 0.5
  size_mid = (size_max - size_min) * 0.5

  # Boundaries to spawn
  x_min = block_length * Math::cos(slope) * -0.5 + size_max
  x_max = block_length * 0.3
  x_mid = (x_max - x_min) * 0.5
  y_min = 0
  y_max = block_width * (total_columns - 0.5)
  y_mid = (y_max - y_min) * 0.5
  z_min = block_length * Math::sin(slope) * 0.5
  z_max = block_length
  z_mid = (z_max - z_min) * 0.5

  # Limit density
  $density_min = 0.1
  $density_max = 5.0
  $density_mid = ($density_max - $density_min) * 0.5

  ###############################################
  #                                             #
  #             PRINT FUNCTIONS                 #
  #                                             #
  ###############################################

  # Print inertia
  # Parameters:
  # _geom: box, cylinder or sphere
  # _sizeX: X size
  # _sizeY: Y size
  # _sizeZ: Z size
  def printInertia(_geom, _sizeX, _sizeY = 0, _sizeZ = 0)

    density = $fun ? rand($density_min..$density_max) : $density_mid
    radius = _sizeX * 0.5

    if (_geom == 'box')

      mass = density * _sizeX * _sizeY * _sizeZ

      ixx = 1.0 / 12 * mass * (_sizeY*_sizeY + _sizeZ*_sizeZ)
      iyy = 1.0 / 12 * mass * (_sizeZ*_sizeZ + _sizeX*_sizeX)
      izz = 1.0 / 12 * mass * (_sizeX*_sizeX + _sizeY*_sizeY)

    elsif (_geom == 'sphere')

      mass = density * 4.0 * Math::PI / 3.0 * radius**3

      ixx = mass * 0.4 * radius**2
      iyy = ixx
      izz = ixx

    elsif (_geom == 'cylinder')

      mass = density * Math::PI * radius**2 * _sizeY

      izz = mass * 0.5 * radius**2
      ixx = (1.0/12.0) * mass * (3 * radius**2 + _sizeY**2)
      iyy = ixx

    else
      return
    end

    "<inertial>\n"\
    "      <mass>" + mass.to_s() + "</mass>\n"\
    "      <inertia>\n"\
    "        <ixx>" + ixx.to_s() + "</ixx>\n"\
    "        <iyy>" + iyy.to_s() + "</iyy>\n"\
    "        <izz>" + izz.to_s() + "</izz>\n"\
    "        <ixy>0.0</ixy>\n"\
    "        <ixz>0.0</ixz>\n"\
    "        <iyz>0.0</iyz>\n"\
    "      </inertia>\n"\
    "    </inertial>\n"

  end

  # Print geometry
  # Parameters:
  # _geom: box, cylinder or sphere
  # _sizeX: X size
  # _sizeY: Y size
  # _sizeZ: Z size
  def printGeom(_geom, _sizeX, _sizeY = 0, _sizeZ = 0)

    if (_geom == 'box')
      "<geometry>\n"\
      "       <box>\n"\
      "         <size>\n"\
      "           " + _sizeX.to_s() + "\n"\
      "           " + _sizeY.to_s() + "\n"\
      "           " + _sizeZ.to_s() + "\n"\
      "         </size>\n"\
      "        </box>\n"\
      "      </geometry>\n"
    elsif (_geom == 'sphere')
      "<geometry>\n"\
      "       <sphere>\n"\
      "         <radius>\n"\
      "           " + (_sizeX * 0.5).to_s() + "\n"\
      "         </radius>\n"\
      "        </sphere>\n"\
      "      </geometry>\n"
    elsif (_geom == 'cylinder')
      "<geometry>\n"\
      "       <cylinder>\n"\
      "         <radius>\n"\
      "           " + (_sizeX * 0.5).to_s() + "\n"\
      "         </radius>\n"\
      "         <length>\n"\
      "           " + _sizeY.to_s() + "\n"\
      "         </length>\n"\
      "        </cylinder>\n"\
      "      </geometry>\n"
    end

  end
%>
<!--
  Generated from distributed_rolling.erb.sdf

  - primary: <%= primary %>
  - secondary: <%= secondary %>
  - performers: <%= performers %>
  - seed: <%= seed %>
  - fun: <%= $fun %>
  - level visuals: <%= level_visuals %>

-->
<sdf version="1.6">
  <world name="default">

    <% if secondary %>
    <plugin
     filename="libignition-gazebo-physics-system.so"
     name="ignition::gazebo::systems::Physics">
    </plugin>
    <% end %>

    <% if primary %>
    <plugin
      filename="libignition-gazebo-scene-broadcaster-system.so"
      name="ignition::gazebo::systems::SceneBroadcaster">
    </plugin>

    <gui fullscreen="0">

      <!-- 3D scene -->
      <plugin filename="Scene3D" name="3D View">
        <ignition-gui>
          <title>3D View</title>
          <property type="bool" key="showTitleBar">false</property>
          <property type="string" key="state">docked</property>
        </ignition-gui>

        <engine>ogre</engine>
        <scene>scene</scene>
        <ambient_light>0.4 0.4 0.4</ambient_light>
        <background_color>0.8 0.8 0.8</background_color>
        <camera_pose>-6 0 6 0 0.5 0</camera_pose>
        <service>/world/default/scene/info</service>
        <pose_topic>/world/default/pose/info</pose_topic>
        <scene_topic>/world/default/scene/info</scene_topic>
        <deletion_topic>/world/default/scene/deletion</deletion_topic>
      </plugin>

      <!-- World control -->
      <plugin filename="WorldControl" name="World control">
        <ignition-gui>
          <title>World control</title>
          <property type="bool" key="showTitleBar">false</property>
          <property type="bool" key="resizable">false</property>
          <property type="double" key="height">72</property>
          <property type="double" key="width">121</property>
          <property type="double" key="z">1</property>

          <property type="string" key="state">floating</property>
          <anchors target="3D View">
            <line own="left" target="left"/>
            <line own="bottom" target="bottom"/>
          </anchors>
        </ignition-gui>

        <play_pause>true</play_pause>
        <step>true</step>
        <start_paused>true</start_paused>
        <service>/world/default/control</service>
        <stats_topic>/world/default/stats</stats_topic>

      </plugin>

      <!--World statistics -->
      <plugin filename="WorldStats" name="World stats">
        <ignition-gui>
          <title>World stats</title>
          <property type="bool" key="showTitleBar">false</property>
          <property type="bool" key="resizable">false</property>
          <property type="double" key="height">110</property>
          <property type="double" key="width">290</property>
          <property type="double" key="z">1</property>

          <property type="string" key="state">floating</property>
          <anchors target="3D View">
            <line own="right" target="right"/>
            <line own="bottom" target="bottom"/>
          </anchors>
        </ignition-gui>

        <sim_time>true</sim_time>
        <real_time>true</real_time>
        <real_time_factor>true</real_time_factor>
        <iterations>true</iterations>
        <topic>/world/default/stats</topic>

      </plugin>

    </gui>
    <% end %>

    <scene>
      <ambient>0.8 0.8 0.8 1.0</ambient>
      <background>0.34 0.39 0.43 1.0</background>
      <grid>false</grid>
      <origin_visual>false</origin_visual>
    </scene>

    <light type="directional" name="sun">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <%
      for perf in (1..performers)
        geom = $fun ? ['box', 'sphere', 'cylinder'].sample() : 'cylinder'
        sizeX = $fun ? rand(size_min..size_max) : size_mid
        sizeY = $fun ? rand(size_min..size_max) : size_mid
        sizeZ = $fun ? rand(size_min..size_max) : size_mid
        posX = $fun ? rand(x_min..x_max) : x_min
        posY = $fun ? rand(y_min..y_max) : (perf-1) * block_width
        posZ = $fun ? rand(z_min..z_max) : z_min
        roll = $fun ? rand(0..Math::PI) : Math::PI * 0.5
        pitch = $fun ? rand(0..Math::PI) : 0
        yaw = $fun ? rand(0..Math::PI) : Math::PI * perf / performers
    %>

    <model name="model_<%= perf.to_s %>">
      <pose>
        <%= posX %>
        <%= posY %>
        <%= posZ %>
        <%= roll %>
        <%= pitch %>
        <%= yaw %>
      </pose>
      <link name="link">
        <%= printInertia(geom, sizeX, sizeY, sizeZ) %>
        <collision name="collision">
          <%= printGeom(geom, sizeX, sizeY, sizeZ) %>
        </collision>
        <visual name="visual">
          <%= printGeom(geom, sizeX, sizeY, sizeZ) %>
          <material>
            <diffuse>
              <%= rand(0..1) %>
              <%= rand(0..1) %>
              <%= rand(0..1) %>
              <%= 1 %>
            </diffuse>
            <specular>
              <%= rand(0..1) %>
              <%= rand(0..1) %>
              <%= rand(0..1) %>
              <%= 1 %>
            </specular>
            <ambient>
              <%= rand(0..1) %>
              <%= rand(0..1) %>
              <%= rand(0..1) %>
              <%= 1 %>
            </ambient>
          </material>
        </visual>
      </link>
    </model>
    <% end %>

    <%
      for block in blocks
    %>
    <model name="<%= block[:name] %>">
      <static>true</static>
      <pose><%= block[:x_pos] %> <%= block[:y_pos] %> <%= block[:z_pos] %> 0 <%= slope %> 0</pose>
      <link name="link">
        <collision name="collision">
          <%= printGeom('box', block_length, block_width, block_thickness) %>
        </collision>
        <visual name="visual">
          <%= printGeom('box', block_length, block_width, block_thickness) %>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <% if level_visuals %>
    <model name="level_vis_<%= block[:name] %>">
      <static>true</static>
      <pose><%= block[:x_pos] %> <%= block[:y_pos] %> <%= block[:z_pos] %> 0 0 0</pose>
      <link name="link">
        <visual name="visual_level">
          <geometry>
            <box>
              <size><%= block_length %> <%= block_width %> <%= level_height %></size>
            </box>
          </geometry>
          <material>
            <ambient>0 0 0.8 0.2</ambient>
            <diffuse>0 0 0.8 0.2</diffuse>
            <specular>0 0 0.8 0.2</specular>
          </material>
        </visual>
        <visual name="visual_buffer">
          <geometry>
            <box>
              <size>
                <%= block_length + level_buffer*2 %>
                <%= block_width + level_buffer*2 %>
                <%= level_height  + level_buffer*2 %>
              </size>
            </box>
          </geometry>
          <material>
            <ambient>0 0.8 0.8 0.2</ambient>
            <diffuse>0 0.8 0.8 0.2</diffuse>
            <specular>0 0.8 0.8 0.2</specular>
          </material>
        </visual>
      </link>
    </model>
    <% end %>
    <% end %>

    <model name="end_block">
      <static>true</static>
      <pose>
        <%= block_length * (total_steps - 0.5) * Math::cos(slope) %>
        <%= block_width * (total_columns - 1) * 0.5 %>
        <%= -block_length * (total_steps - 0.5) * Math::sin(slope) + level_height * 0.5 %>
        0
        0
        0
      </pose>
      <link name="link">
        <collision name="collision">
          <%= printGeom('box', block_thickness, block_width * total_columns, level_height) %>
        </collision>
        <visual name="visual">
          <%= printGeom('box', block_thickness, block_width * total_columns, level_height) %>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <model name="side_block_A">
      <static>true</static>
      <pose>
        <%= block_length * (total_steps - 0.5) * 0.5 * Math::cos(slope) %>
        <%= block_width * -0.5 %>
        <%= -block_length * (total_steps - 0.5) * 0.5 * Math::sin(slope) + level_height * 0.5 %>
        0
        <%= slope %>
        0
      </pose>
      <link name="link">
        <collision name="collision">
          <%= printGeom('box', block_length * total_steps, block_thickness, level_height) %>
        </collision>
        <visual name="visual">
          <%= printGeom('box', block_length * total_steps, block_thickness, level_height) %>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <model name="side_block_B">
      <static>true</static>
      <pose>
        <%= block_length * (total_steps - 0.5) * 0.5 * Math::cos(slope) %>
        <%= block_width * (total_columns - 0.5) %>
        <%= -block_length * (total_steps - 0.5) * 0.5 * Math::sin(slope) + level_height * 0.5 %>
        0
        <%= slope %>
        0
      </pose>
      <link name="link">
        <collision name="collision">
          <%= printGeom('box', block_length * total_steps, block_thickness, level_height) %>
        </collision>
        <visual name="visual">
          <%= printGeom('box', block_length * total_steps, block_thickness, level_height) %>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <plugin name="ignition::gazebo" filename="dummy">

    <%
      for perf in (1..performers)
    %>
      <performer name="perf_<%= perf.to_s %>">
        <ref>model_<%= perf.to_s %></ref>
        <geometry>
          <box>
            <size>
              <%= size_max %>
              <%= size_max %>
              <%= size_max %>
            </size>
          </box>
        </geometry>
      </performer>
    <% end %>

    <%
      for block in blocks
    %>
    <level name="level_<%= block[:name] %>">
      <pose><%= block[:x_pos] %> <%= block[:y_pos] %> <%= block[:z_pos] %> 0 0 0</pose>
      <geometry>
        <box>
          <size><%= block_length %> <%= block_width %> <%= level_height %></size>
        </box>
      </geometry>
      <buffer><%= level_buffer %></buffer>
      <ref><%= block[:name] %></ref>
    </level>
    <% end %>


    </plugin>

  </world>
</sdf>
